<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Regional Coverage by Theme</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-geo-projection@4"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:wght@300;400;600;700;900&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #fafaf8;
      --fg: #111;
      --fg-muted: #666;
      --fg-faint: #bbb;
      --border: #e0e0dc;

      --c0: #354765;
      /* Cybersecurity/Cybercrime – red */
      --c1: #407A8F;
      /* Education/Skills/Research – steel blue */
      --c2: #5BB0B9;
      /* Infrastructure – amber */
      --c3: #A2CDA6;
      /* Regulation/Governance/Political – forest green */
      --c4: #FFDE75;
      /* Security/Military/Defence – violet */

      --dim: 0.12;
      --transition: 200ms ease;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Nunito Sans', sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
    }

    #app {
      /* max-width: 1000px; */
      margin: 0 auto;
      padding: 2rem 1.5rem 4rem;
    }

    header {
      margin-bottom: 1.5rem;
    }

    header h1 {
      font-size: clamp(1.2rem, 2.5vw, 1.8rem);
      font-weight: 900;
      letter-spacing: -0.02em;
      line-height: 1.1;
    }

    header p {
      margin-top: 0.4rem;
      font-size: 0.85rem;
      color: var(--fg-muted);
      font-weight: 400;
    }

    /* LEGEND */
    #legend {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1.2rem;
      margin-bottom: 1.2rem;
      padding: 0.8rem 1rem;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.78rem;
      font-weight: 600;
      cursor: pointer;
      opacity: 1;
      transition: opacity var(--transition);
    }

    .legend-swatch {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* MAP */
    #main-row {
      display: flex;
      gap: 1rem;
      align-items: stretch;
      margin-bottom: 2rem;
      height: 80vh;
    }

    #map-container {
      flex: 0 0 50%;
      height: 70vh;
      margin-bottom: 0;
      display: flex;
      flex-direction: column;
    }

    #map-svg {
      display: block;
      width: 100%;
      flex: 1 1 0;
      /* fill remaining height after legend */
      min-height: 0;
    }

    .coastline {
      fill: none;
      stroke: #ccc;
      stroke-width: 0.6;
    }

    .region-label {
      font-family: 'Nunito Sans', sans-serif;
      font-size: 10px;
      font-weight: 700;
      fill: var(--fg);
      text-anchor: middle;
      pointer-events: none;
      letter-spacing: 0.01em;
    }

    .dorling-circle {
      stroke: #fff;
      stroke-width: 1.5;
      cursor: pointer;
      transition: opacity var(--transition);
    }

    /* TOOLTIP */
    #tooltip {
      position: fixed;
      background: #fff;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.55rem 0.85rem;
      font-size: 0.8rem;
      line-height: 1.5;
      pointer-events: none;
      opacity: 0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);
      z-index: 100;
      max-width: 220px;
      transition: opacity 100ms ease;
    }

    #tooltip strong {
      font-weight: 900;
      display: block;
      margin-bottom: 0.15rem;
    }

    #tooltip .tt-theme {
      color: var(--fg-muted);
      font-size: 0.75rem;
    }

    #tooltip .tt-perc {
      font-weight: 700;
      font-size: 0.95rem;
      margin-top: 0.2rem;
    }

    /* SECTION DIVIDER */
    .section-label {
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--fg-muted);
      margin-bottom: 0.8rem;
      padding-bottom: 0.4rem;
      border-bottom: 1px solid var(--border);
    }

    /* DOTPLOT */
    #dotplots-row {
      flex: 1 1 0;
      display: flex;
      flex-direction: column;
      /* stack vertically instead of side by side */
      gap: 1rem;
      align-items: stretch;
    }

    .dotplot-col {
      flex: 1 1 0;
      /* each takes half the column height */
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .dotplot-container {
      flex: 1 1 0;
      /* fill available height */
      width: 100%;
      min-width: 0;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #fff;
      padding: 1.2rem 1.2rem 0.8rem;
      overflow-x: hidden;
      /* both axes */
    }

    .dotplot-svg {
      display: block;
      overflow: visible;
    }

    #dotplot-container {
      /* legacy — keep for backward compat if anything refs it */
    }

    #dotplot-svg {
      display: block;
      overflow: visible;
    }

    .dot-item {
      cursor: pointer;
      transition: opacity var(--transition);
    }

    .dot-theme-label {
      font-family: 'Nunito Sans', sans-serif;
      font-size: 11px;
      font-weight: 700;
      fill: var(--fg);
      dominant-baseline: middle;
    }

    .dot-axis-line {
      stroke: var(--border);
      stroke-width: 1;
      stroke-dasharray: none;
    }

    @media (max-width: 600px) {
      #app {
        padding: 1rem 0.8rem 3rem;
      }

      .region-label {
        font-size: 8px;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <h1>Regional Coverage by Theme</h1>
      <p>Dorling cartogram — circle area proportional to share of total items in each region. Hover to explore. Click
        legend to filter.</p>
    </header>
    <div id="main-row">
      <div id="map-container">
        <div id="legend"></div>
        <svg id="map-svg"></svg>
      </div>
      <div id="dotplots-row">
        <div class="dotplot-col">
          <div class="section-label">By theme</div>
          <div class="dotplot-container" id="dotplot-theme-container">
            <svg class="dotplot-svg" id="dotplot-svg"></svg>
          </div>
        </div>
        <div class="dotplot-col">
          <div class="section-label">By region</div>
          <div class="dotplot-container" id="dotplot-region-container">
            <svg class="dotplot-svg" id="dotplot-region-svg"></svg>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="tooltip"></div>

  <script>
    // ─────────────────────────────────────────────
    // DATA
    // ─────────────────────────────────────────────

    let RAW, dotData, data;

    // ─────────────────────────────────────────────
    // CONSTANTS
    // ─────────────────────────────────────────────
    const THEMES = [
      "Cybersecurity/Cybercrime",
      "Education/Skills/Research",
      "Infrastructure",
      "Regulation/Governance/Political",
      "Security/Military/Defence"
    ];

    const THEME_COLORS = {
      "Cybersecurity/Cybercrime": "#354765",
      "Education/Skills/Research": "#407A8F",
      "Infrastructure": "#5BB0B9",
      "Regulation/Governance/Political": "#A2CDA6",
      "Security/Military/Defence": "#FFDE75"
    };

    const SHORT_LABELS = {
      "Cybersecurity/Cybercrime": "Cybersecurity",
      "Education/Skills/Research": "Education",
      "Infrastructure": "Infrastructure",
      "Regulation/Governance/Political": "Regulation",
      "Security/Military/Defence": "Security/Defence"
    };

    const REGION_SHORT = {
      "Arctic": "Arctic",
      "Central Asia": "Central Asia",
      "EU Neighbourhood Countries": "EU Neighbourhood",
      "Global": "Global",
      "Indo-Pacific (includes South-East Asia)": "Indo-Pacific",
      "MENA": "MENA",
      "North America": "North America",
      "North-East Asia": "N-E Asia",
      "South America": "South America",
      "Sub-Saharan Africa": "Sub-Saharan Africa"
    };

    const MAX_RADIUS = 28; // px at max perc (for 1200px wide map)
    const MIN_RADIUS = 5;  // minimum visible radius for n>0

    // ─────────────────────────────────────────────
    // DATA PREP
    // ─────────────────────────────────────────────
    Promise.all([
      fetch('https://raw.githubusercontent.com/euissR/analysis_2026_02-CB-cyber-projects/refs/heads/main/data_full_regions.geojson').then(r => r.json()),
      fetch('https://raw.githubusercontent.com/euissR/analysis_2026_02-CB-cyber-projects/refs/heads/main/data_full.json').then(r => r.json())
    ]).then(([geojson, csv]) => {
      RAW = geojson;
      dotData = csv;
      data = RAW.features.map(f => ({        // ← was `const data = ...` at top level
        region: f.properties.region,
        theme: f.properties.theme,
        n: f.properties.n,
        perc: f.properties.perc,
        lng: f.geometry.coordinates[0],
        lat: f.geometry.coordinates[1]
      })).filter(d => d.n > 0);
      initMap();
      initDotplot();
    });

    // ─────────────────────────────────────────────
    // STATE
    // ─────────────────────────────────────────────
    let hoveredTheme = null;
    let hoveredKey = null; // region+theme key (for dotplot→map)
    let activeTheme = null; // from legend click

    // ─────────────────────────────────────────────
    // TOOLTIP
    // ─────────────────────────────────────────────
    const tooltip = document.getElementById('tooltip');

    function showTooltip(html, event) {
      tooltip.innerHTML = html;
      tooltip.style.opacity = '1';
      moveTooltip(event);
    }

    function moveTooltip(event) {
      const pad = 14;
      let x = event.clientX + pad;
      let y = event.clientY + pad;
      const tw = tooltip.offsetWidth, th = tooltip.offsetHeight;
      if (x + tw > window.innerWidth - 8) x = event.clientX - tw - pad;
      if (y + th > window.innerHeight - 8) y = event.clientY - th - pad;
      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';
    }

    function hideTooltip() {
      tooltip.style.opacity = '0';
    }

    // ─────────────────────────────────────────────
    // LEGEND
    // ─────────────────────────────────────────────
    const legendEl = document.getElementById('legend');
    THEMES.forEach(t => {
      const item = document.createElement('div');
      item.className = 'legend-item';
      item.innerHTML = `<div class="legend-swatch" style="background:${THEME_COLORS[t]}"></div><span>${SHORT_LABELS[t]}</span>`;
      item.addEventListener('click', () => {
        if (activeTheme === t) {
          activeTheme = null;
        } else {
          activeTheme = t;
        }
        updateBrush();
      });
      legendEl.appendChild(item);
    });

    // ─────────────────────────────────────────────
    // MAP
    // ─────────────────────────────────────────────
    const mapSvg = d3.select('#map-svg');
    const mapContainer = document.getElementById('map-container');

    function radiusScale(perc) {
      return Math.max(MIN_RADIUS, Math.sqrt(perc) * MAX_RADIUS);
    }

    function initMap() {
      const W = mapContainer.clientWidth;
      const H = mapSvg.node().clientHeight;
      mapSvg.attr('viewBox', `0 0 ${W} ${H}`).attr('height', H);

      const projection = d3.geoEisenlohr()
        .scale(W / 6.5)
        .translate([W / 2 - 30, H / 2 + 100]);

      const path = d3.geoPath().projection(projection);

      const g = mapSvg.append('g').attr('class', 'map-root');

      // Coastlines from GISCO
      fetch('https://gisco-services.ec.europa.eu/distribution/v2/coas/geojson/COAS_RG_60M_2016_4326.geojson')
        .then(r => r.json())
        .then(coast => {
          g.append('g').attr('class', 'coastlines')
            .selectAll('path')
            .data(coast.features)
            .join('path')
            .attr('class', 'coastline')
            .attr('d', path);

          drawDorling(g, projection, W, H);
        })
        .catch(() => {
          // fallback if CORS blocks
          drawDorling(g, projection, W, H);
        });
    }

    function drawDorling(g, projection, W, H) {
      // Project geographic centers
      const nodes = data.map(d => {
        const [px, py] = projection([d.lng, d.lat]);
        return {
          ...d,
          r: radiusScale(d.perc),
          gx: px, gy: py,
          x: px + (Math.random() - 0.5) * 10,
          y: py + (Math.random() - 0.5) * 10,
          key: d.region + '|' + d.theme
        };
      });

      // Force simulation for Dorling layout
      const sim = d3.forceSimulation(nodes)
        .force('x', d3.forceX(d => d.gx).strength(0.6))
        .force('y', d3.forceY(d => d.gy).strength(0.6))
        .force('collide', d3.forceCollide(d => d.r + 1.5).strength(1))
        .stop();

      for (let i = 0; i < 200; i++) sim.tick();

      // Clamp to bounds
      nodes.forEach(n => {
        n.x = Math.max(n.r + 2, Math.min(W - n.r - 2, n.x));
        n.y = Math.max(n.r + 2, Math.min(H - n.r - 2, n.y));
      });

      // Region label positions: centroid of each region's circles
      const regionGroups = d3.group(nodes, d => d.region);
      const regionLabelPos = new Map();
      regionGroups.forEach((nodes, region) => {
        const meanX = d3.mean(nodes, d => d.x);
        const minY = d3.min(nodes, d => d.y - d.r);
        regionLabelPos.set(region, { x: meanX, y: minY - 6 });
      });

      // Circles
      const circles = g.append('g').attr('class', 'dorling-circles')
        .selectAll('circle')
        .data(nodes, d => d.key)
        .join('circle')
        .attr('class', 'dorling-circle')
        .attr('data-theme', d => d.theme)
        .attr('data-key', d => d.key)
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('r', d => d.r)
        .attr('fill', d => THEME_COLORS[d.theme])
        .on('mouseenter', function (event, d) {
          hoveredTheme = d.theme;
          hoveredKey = d.key;
          updateBrush();
          showTooltip(
            `<strong>${d.region}</strong>
         <div class="tt-theme">${d.theme}</div>
         <div class="tt-perc">${Math.round(d.perc * 100)}% of region total</div>`,
            event
          );
        })
        .on('mousemove', moveTooltip)
        .on('mouseleave', function () {
          hoveredTheme = null;
          hoveredKey = null;
          updateBrush();
          hideTooltip();
        });

      // Region labels
      g.append('g').attr('class', 'region-labels')
        .selectAll('text')
        .data([...regionLabelPos.entries()])
        .join('text')
        .attr('class', 'region-label')
        .attr('x', d => d[1].x)
        .attr('y', d => d[1].y)
        .text(d => REGION_SHORT[d[0]] || d[0]);

      // expose for brush updates
      window._mapCircles = circles;
    }

    // ─────────────────────────────────────────────
    // DOTPLOT
    // ─────────────────────────────────────────────
    const DOT_R = 6;
    const DOT_GAP = 2;
    const DOT_STEP = DOT_R * 2 + DOT_GAP;
    const DOTS_PER_ROW = 40;
    const THEME_GAP = 18;
    const LABEL_W = 110;
    const DOT_AREA_PAD_R = 16;

    // ─────────────────────────────────────────────
    // DOTPLOT — shared renderer
    // axis: 'theme' | 'region'
    // ─────────────────────────────────────────────
    function buildDotplot({ axis, containerId, svgId, dpKey }) {
      const container = document.getElementById(containerId);
      const containerW = container.clientWidth - 24;

      const REGIONS = [
        "Arctic", "Central Asia", "EU Neighbourhood Countries", "Global",
        "Indo-Pacific (includes South-East Asia)", "MENA", "North America",
        "North-East Asia", "South America", "Sub-Saharan Africa"
      ];

      // Build group keys + labels + colors
      let groups;
      if (axis === 'theme') {
        groups = THEMES.map(t => ({
          key: t,
          label: SHORT_LABELS[t],
          color: THEME_COLORS[t],
          dots: dotData.filter(d => d.theme === t)
            .sort((a, b) => REGIONS.indexOf(a.region) - REGIONS.indexOf(b.region))
        }));
      } else {
        groups = REGIONS.map(r => ({
          key: r,
          label: REGION_SHORT[r] || r,
          color: '#888',
          dots: dotData.filter(d => d.region === r)
            .sort((a, b) => THEMES.indexOf(a.theme) - THEMES.indexOf(b.theme))
        }));
      }

      // Assign grid positions per group
      let maxCols = 0;
      groups.forEach(g => {
        g.dots.forEach((dot, i) => {
          dot[`col_${axis}`] = i % DOTS_PER_ROW;
          dot[`row_${axis}`] = Math.floor(i / DOTS_PER_ROW);
        });
        g.numRows = Math.ceil(g.dots.length / DOTS_PER_ROW);
        maxCols = Math.max(maxCols, Math.min(g.dots.length, DOTS_PER_ROW));
      });

      // Y offsets per group band
      let yOffset = DOT_R + 4;
      groups.forEach(g => {
        g.yBase = yOffset;
        yOffset += g.numRows * DOT_STEP + THEME_GAP;
      });
      const totalH = yOffset + 8;

      const svgW = LABEL_W + maxCols * DOT_STEP + DOT_AREA_PAD_R;
      const dpSvg = d3.select(`#${svgId}`)
        .attr('width', Math.max(svgW, containerW))
        .attr('height', totalH);

      groups.forEach((g, gi) => {
        const { key, label, color, dots, numRows, yBase } = g;

        // Separator
        if (gi > 0) {
          dpSvg.append('line')
            .attr('class', 'dot-axis-line')
            .attr('x1', 0)
            .attr('x2', Math.max(svgW, containerW))
            .attr('y1', yBase - THEME_GAP / 2 - 2)
            .attr('y2', yBase - THEME_GAP / 2 - 2);
        }

        // Group label
        const bandH = numRows * DOT_STEP;
        // For region axis, colour dots by theme; label is in region color (neutral)
        dpSvg.append('text')
          .attr('class', 'dot-theme-label')
          .attr('x', 0)
          .attr('y', yBase + bandH / 2)
          .attr('fill', axis === 'theme' ? color : '#555')
          .text(label);

        dpSvg.append('g')
          .selectAll('circle')
          .data(dots)
          .join('circle')
          .attr('class', 'dot-item')
          .attr('data-theme', d => d.theme)
          .attr('data-key', d => d.region + '|' + d.theme)
          .attr('cx', d => LABEL_W + d[`col_${axis}`] * DOT_STEP + DOT_R)
          .attr('cy', d => yBase + d[`row_${axis}`] * DOT_STEP)
          .attr('r', DOT_R)
          .attr('fill', d => axis === 'theme' ? color : THEME_COLORS[d.theme])
          .attr('stroke', '#fff')
          .attr('stroke-width', 1.2)
          .on('mouseenter', function (event, d) {
            hoveredTheme = d.theme;
            hoveredKey = d.region + '|' + d.theme;
            updateBrush();
            showTooltip(
              `<strong>${d.title}</strong>
             <div class="tt-theme">${d.theme}</div>
             <div class="tt-theme">${d.region}</div>`,
              event
            );
          })
          .on('mousemove', moveTooltip)
          .on('mouseleave', function () {
            hoveredTheme = null;
            hoveredKey = null;
            updateBrush();
            hideTooltip();
          });
      });

      window[dpKey] = dpSvg;
    }

    function initDotplot() {
      buildDotplot({ axis: 'theme', containerId: 'dotplot-theme-container', svgId: 'dotplot-svg', dpKey: '_dpSvg' });
      buildDotplot({ axis: 'region', containerId: 'dotplot-region-container', svgId: 'dotplot-region-svg', dpKey: '_dpSvgRegion' });
    }

    // ─────────────────────────────────────────────
    // LINKED BRUSHING
    // ─────────────────────────────────────────────
    function updateBrush() {
      const filterTheme = activeTheme || hoveredTheme;
      const filterKey = hoveredKey;

      // Map circles
      if (window._mapCircles) {
        window._mapCircles.attr('opacity', d => {
          if (!filterTheme && !filterKey) return 1;
          // If hovering from dotplot, highlight only the matching key circle, dim others of different theme
          if (filterKey) {
            const key = d.region + '|' + d.theme;
            if (key === filterKey) return 1;
            if (d.theme === filterTheme) return 0.35;
            return 0.08;
          }
          // Hovering on map or legend filter: dim different themes
          if (d.theme === filterTheme) return 1;
          return 0.1;
        });
      }

      // Dotplot dots
      if (window._dpSvg) {
        window._dpSvg.selectAll('.dot-item').attr('opacity', d => {
          if (!filterTheme && !filterKey) return 1;
          if (filterKey) {
            // From dotplot hover: dim different theme, full opacity same theme+region
            const key = d.region + '|' + d.theme;
            if (key === filterKey) return 1;
            if (d.theme === filterTheme) return 0.3;
            return 0.08;
          }
          // From map hover or legend
          if (d.theme === filterTheme) return 1;
          return 0.1;
        });
      }

      // Region dotplot dots
      if (window._dpSvgRegion) {
        window._dpSvgRegion.selectAll('.dot-item').attr('opacity', d => {
          if (!filterTheme && !filterKey) return 1;
          if (filterKey) {
            const key = d.region + '|' + d.theme;
            if (key === filterKey) return 1;
            if (d.theme === filterTheme) return 0.3;
            return 0.08;
          }
          if (d.theme === filterTheme) return 1;
          return 0.1;
        });
      }

      // Legend items
      document.querySelectorAll('.legend-item').forEach(el => {
        const t = el.querySelector('span').textContent;
        const fullTheme = Object.keys(SHORT_LABELS).find(k => SHORT_LABELS[k] === t);
        if (!filterTheme) {
          el.style.opacity = '1';
        } else {
          el.style.opacity = (fullTheme === filterTheme) ? '1' : '0.35';
        }
      });
    }

    // ─────────────────────────────────────────────
    // INIT
    // ─────────────────────────────────────────────

    // Responsive resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        mapSvg.selectAll('*').remove();
        document.getElementById('dotplot-svg').innerHTML = '';
        document.getElementById('dotplot-region-svg').innerHTML = '';
        initMap();
        initDotplot();
      }, 300);
    });
  </script>
</body>

</html>